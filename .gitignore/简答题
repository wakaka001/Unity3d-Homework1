1.解释 游戏对象（GameObjects） 和 资源（Assets）的区别与联系。 
  游戏对象：直接出现在游戏场景中，是资源整合的具体表现。对象一般有玩家、敌人、环境、摄像机和音乐等虚拟父类，这些父节点本身没有实体，但它们的子类真正包含  了游戏中会出现的对象。
  资源：资源可以被多个对象使用。有些资源作为模板，可实例化成游戏中具体的对象。资源文件夹通常有对象、材质、场景、声音、预设、贴图、脚本、动作，在这些文件夹下可以继续进行划分。

2.下载几个游戏案例，分别总结资源、对象组织的结构（指资源的目录组织结构与游戏对象树的层次结构）

3.编写一个代码，使用 debug 语句来验证 MonoBehaviour 基本行为或事件触发的条件
  基本行为包括 Awake() Start() Update() FixedUpdate() LateUpdate()
  常用事件包括 OnGUI() OnDisable() OnEnable()
  public classNewBehaviourScript : MonoBehaviour {
    void Awake() {
      Debug.Log("Awake!");

    }
		
    void Start() {
			Debug.Log("Start!");
		}
		
		void Update() {
			Debug.Log("Update!");
		}
		
		void FixedUpdate() {
			Debug.Log("onFixedUpdate!");
		}

    void LateUpdate() {
			Debug.Log("onLateUpdate!");
		}

    void OnGUI() {
			Debug.Log("onGUI!");
		}

    void OnDisable() {
			Debug.Log("onDisable!");
		}

    void OnEnable() {
			Debug.Log("onDestroy!");
		}
  }

4.查找脚本手册，了解 GameObject，Transform，Component 对象
  分别翻译官方对三个对象的描述（Description）
	Gameobject:游戏中的每个对象都是一个游戏对象。然而，游戏对象自己不做任何事。他们需要专有属性，才可以成为一个角色，一个环境，或一个特殊效果。但是每一个对象要做很多不同的事情。
	Transform:
	
描述下图中 table 对象（实体）的属性、table 的 Transform 的属性、 table 的部件
本题目要求是把可视化图形编程界面与 Unity API 对应起来，当你在 Inspector 面板上每一个内容，应该知道对应 API。
例如：table 的对象是 GameObject，第一个选择框是 activeSelf 属性。
用 UML 图描述 三者的关系（请使用 UMLet 14.1.1 stand-alone版本出图）


5.整理相关学习资料，编写简单代码验证以下技术的实现：
	查找对象
	添加子对象
	遍历对象树
	清除所有子对象
	查找对象		通过名字查找：public static GameObject Find(string name)
						 通过标签查找单个对象：public static GameObject FindWithTag(string tag)
						 通过标签查找多个对象：public static GameObject[] FindGameObjectsWithTag(string tag)
	添加子对象: public static GameObect CreatePrimitive(PrimitiveTypetype)
	遍历对象树: foreach (Transform child in transform) {}
	清除所有子对象: foreach (Transform child in transform) { Destroy(child.gameObject);}

6.资源预设（Prefabs）与 对象克隆 (clone)
	预设（Prefabs）有什么好处？
	预设类似于一个模板，通过预设可以创建相同属性的对象，这些对象和预设关联。一旦预设发生改变，所有通过预设实例化的对象都会产生相应的变化（适合批量处理）。
	
	预设与对象克隆 (clone or copy or Instantiate of Unity Object) 关系？
	对象克隆不受克隆本体的影响，因此A对象克隆的对象B不会因为A的改变而相应改变。
	
	制作 table 预制，写一段代码将 table 预制资源实例化成游戏对象
	
7.尝试解释组合模式（Composite Pattern / 一种设计模式）。使用 BroadcastMessage()方法向子对象发送消息
	组合模式允许用户将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。
	子类对象（my_obj）方法：
	void sayHello() {
		 print("Hello!");
	}

	父类对象（GameObject）方法：
	void Start () {
		this.BroadcastMessage("sayHello");
	}
	
	
